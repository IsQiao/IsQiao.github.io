---
title: 微服务相关
---

# 模式
## 聚合器
负载均衡->网关->服务A->Cahe->Db
## 代理
和第一个差不多？
## 链式
适合耦合比较高的场景，如bll->dll
## 分支
聚合起模式的扩展，允许同时调用两个微服务链
## 数据共享
##  异步消息传递


# Zookeeper
主要解决分布式锁的问题、防止发生网络问题在传统模式发生双主节点导致这个服务混乱的问题。
zookeeper自己决定主节点、当主节点有问题时、发出主节点选举产生新的主节点。
老的主节点等到自身恢复后，再向zookeeper注册自己，这时候注册的节点位置靠后，再产生新的主节点选举。

## 为什么要使用分布式锁
### 解决的问题

#### 场景

* 场景: 库存2，三个用户同时下单，因为有库存，若允许下单2-3=-1就是有问题的
*

#### 解决
1. 高并发的情况下，在同一时间只允许一个线程执行。 
2. 单机环境，使用Java中提供的并发处理API。
3. 分布式系统时多线程多进程多机器的，所以单机部署的并发控制策略失效。
4. 所以需要一种跨JVM的护持机制来控制共享资源的访问

### 条件
1. 分布式系统环境下，一个方法在同一时间只能呗一个机器的一个线程执行
2. 高可用的获取锁和释放锁  
3. 高性能的获取锁和释放锁
4. 具备可重入特性（可理解为重新进入，由多于一个任务并发使用，而不必担心数据错误）
5. 具备锁失效机制，防止死锁
6. 具备非阻塞锁特性，级没有获取到锁将直接返回获取锁失败

## 步骤
线程执行判断是否满足，满足加锁然后执行，执行完成后再删掉自己的节点。（待确认是否时这样，有疑问）
# 关键词
* 重试
* 限流
	* 客户端
	* 服务端
* 负载均衡
* 熔断
* 降级
* 分布式锁
* 服务雪崩

# 架构图
## 1

![](/images/Screen%20Shot%202020-03-19%20at%2011.36.42%20PM.png)